类型分支 · Go语言圣经

- [前言](../)- [Go语言起源](../ch0/ch0-01.md)
    - [Go语言项目](../ch0/ch0-02.md)
    - [本书的组织](../ch0/ch0-03.md)
    - [更多的信息](../ch0/ch0-04.md)
    - [致谢](../ch0/ch0-05.md)
- [入门](../ch1/ch1.md)- [Hello, World](../ch1/ch1-01.md)
    - [命令行参数](../ch1/ch1-02.md)
    - [查找重复的行](../ch1/ch1-03.md)
    - [GIF动画](../ch1/ch1-04.md)
    - [获取URL](../ch1/ch1-05.md)
    - [并发获取多个URL](../ch1/ch1-06.md)
    - [Web服务](../ch1/ch1-07.md)
    - [本章要点](../ch1/ch1-08.md)
- [程序结构](../ch2/ch2.md)- [命名](../ch2/ch2-01.md)
    - [声明](../ch2/ch2-02.md)
    - [变量](../ch2/ch2-03.md)
    - [赋值](../ch2/ch2-04.md)
    - [类型](../ch2/ch2-05.md)
    - [包和文件](../ch2/ch2-06.md)
    - [作用域](../ch2/ch2-07.md)
- [基础数据类型](../ch3/ch3.md)- [整型](../ch3/ch3-01.md)
    - [浮点数](../ch3/ch3-02.md)
    - [复数](../ch3/ch3-03.md)
    - [布尔型](../ch3/ch3-04.md)
    - [字符串](../ch3/ch3-05.md)
    - [常量](../ch3/ch3-06.md)
- [复合数据类型](../ch4/ch4.md)- [数组](../ch4/ch4-01.md)
    - [Slice](../ch4/ch4-02.md)
    - [Map](../ch4/ch4-03.md)
    - [结构体](../ch4/ch4-04.md)
    - [JSON](../ch4/ch4-05.md)
    - [文本和HTML模板](../ch4/ch4-06.md)
- [函数](../ch5/ch5.md)- [函数声明](../ch5/ch5-01.md)
    - [递归](../ch5/ch5-02.md)
    - [多返回值](../ch5/ch5-03.md)
    - [错误](../ch5/ch5-04.md)
    - [函数值](../ch5/ch5-05.md)
    - [匿名函数](../ch5/ch5-06.md)
    - [可变参数](../ch5/ch5-07.md)
    - [Deferred函数](../ch5/ch5-08.md)
    - [Panic异常](../ch5/ch5-09.md)
    - [Recover捕获异常](../ch5/ch5-10.md)
- [方法](../ch6/ch6.md)- [方法声明](../ch6/ch6-01.md)
    - [基于指针对象的方法](../ch6/ch6-02.md)
    - [通过嵌入结构体来扩展类型](../ch6/ch6-03.md)
    - [方法值和方法表达式](../ch6/ch6-04.md)
    - [示例: Bit数组](../ch6/ch6-05.md)
    - [封装](../ch6/ch6-06.md)
- [接口](ch7.md)- [接口是合约](ch7-01.md)
    - [接口类型](ch7-02.md)
    - [实现接口的条件](ch7-03.md)
    - [flag.Value接口](ch7-04.md)
    - [接口值](ch7-05.md)
    - [sort.Interface接口](ch7-06.md)
    - [http.Handler接口](ch7-07.md)
    - [error接口](ch7-08.md)
    - [示例: 表达式求值](ch7-09.md)
    - [类型断言](ch7-10.md)
    - [基于类型断言识别错误类型](ch7-11.md)
    - [通过类型断言查询接口](ch7-12.md)
    - [类型分支](ch7-13.md)
    - [示例: 基于标记的XML解码](ch7-14.md)
    - [补充几点](ch7-15.md)
- [Goroutines和Channels](../ch8/ch8.md)- [Goroutines](../ch8/ch8-01.md)
    - [示例: 并发的Clock服务](../ch8/ch8-02.md)
    - [示例: 并发的Echo服务](../ch8/ch8-03.md)
    - [Channels](../ch8/ch8-04.md)
    - [并发的循环](../ch8/ch8-05.md)
    - [示例: 并发的Web爬虫](../ch8/ch8-06.md)
    - [基于select的多路复用](../ch8/ch8-07.md)
    - [示例: 并发的目录遍历](../ch8/ch8-08.md)
    - [并发的退出](../ch8/ch8-09.md)
    - [示例: 聊天服务](../ch8/ch8-10.md)
- [基于共享变量的并发](../ch9/ch9.md)- [竞争条件](../ch9/ch9-01.md)
    - [sync.Mutex互斥锁](../ch9/ch9-02.md)
    - [sync.RWMutex读写锁](../ch9/ch9-03.md)
    - [内存同步](../ch9/ch9-04.md)
    - [sync.Once惰性初始化](../ch9/ch9-05.md)
    - [竞争条件检测](../ch9/ch9-06.md)
    - [示例: 并发的非阻塞缓存](../ch9/ch9-07.md)
    - [Goroutines和线程](../ch9/ch9-08.md)
- [包和工具](../ch10/ch10.md)- [包简介](../ch10/ch10-01.md)
    - [导入路径](../ch10/ch10-02.md)
    - [包声明](../ch10/ch10-03.md)
    - [导入声明](../ch10/ch10-04.md)
    - [包的匿名导入](../ch10/ch10-05.md)
    - [包和命名](../ch10/ch10-06.md)
    - [工具](../ch10/ch10-07.md)
- [测试](../ch11/ch11.md)- [go test](../ch11/ch11-01.md)
    - [测试函数](../ch11/ch11-02.md)
    - [测试覆盖率](../ch11/ch11-03.md)
    - [基准测试](../ch11/ch11-04.md)
    - [剖析](../ch11/ch11-05.md)
    - [示例函数](../ch11/ch11-06.md)
- [反射](../ch12/ch12.md)- [为何需要反射?](../ch12/ch12-01.md)
    - [reflect.Type和reflect.Value](../ch12/ch12-02.md)
    - [Display递归打印](../ch12/ch12-03.md)
    - [示例: 编码S表达式](../ch12/ch12-04.md)
    - [通过reflect.Value修改值](../ch12/ch12-05.md)
    - [示例: 解码S表达式](../ch12/ch12-06.md)
    - [获取结构体字段标签](../ch12/ch12-07.md)
    - [显示一个类型的方法集](../ch12/ch12-08.md)
    - [几点忠告](../ch12/ch12-09.md)
- [底层编程](../ch13/ch13.md)- [unsafe.Sizeof, Alignof 和 Offsetof](../ch13/ch13-01.md)
    - [unsafe.Pointer](../ch13/ch13-02.md)
    - [示例: 深度相等判断](../ch13/ch13-03.md)
    - [通过cgo调用C代码](../ch13/ch13-04.md)
    - [几点忠告](../ch13/ch13-05.md)
- [附录](../appendix/appendix.html)- [附录A：原文勘误](../appendix/appendix-a-errata.html)
    - [附录B：作者译者](../appendix/appendix-b-author.html)
    - [附录C：译文授权](../appendix/appendix-c-cpoyright.html)
    - [附录D：其它语言](../appendix/appendix-d-translations.html)
- [本书使用 GitBook 发布](https://www.gitbook.com)

# [类型分支](..)

## 7.13. 类型分支

接口被以两种不同的方式使用。在第一个方式中，以io.Reader，io.Writer，fmt.Stringer，sort.Interface，http.Handler和error为典型，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。

第二个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。类型断言用来动态地区别这些类型，使得对每一种情况都不一样。在这个方式中，重点在于具体的类型满足这个接口，而不在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为discriminated unions（可辨识联合）。

如果你熟悉面向对象编程，你可能会将这两种方式当作是subtype polymorphism（子类型多态）和 ad hoc polymorphism（非参数多态），但是你不需要去记住这些术语。对于本章剩下的部分，我们将会呈现一些第二种方式的例子。

和其它那些语言一样，Go语言查询一个SQL数据库的API会干净地将查询中固定的部分和变化的部分分开。一个调用的例子可能看起来像这样：

```lang-go
import "database/sql"

func listTracks(db sql.DB, artist string, minYear, maxYear int) {
    result, err := db.Exec(
        "SELECT * FROM tracks WHERE artist = ? AND ? <= year AND year <= ?",
        artist, minYear, maxYear)
    // ...
}

```

Exec方法使用SQL字面量替换在查询字符串中的每个'?'；SQL字面量表示相应参数的值，它有可能是一个布尔值，一个数字，一个字符串，或者nil空值。用这种方式构造查询可以帮助避免SQL注入攻击；这种攻击就是对手可以通过利用输入内容中不正确的引号来控制查询语句。在Exec函数内部，我们可能会找到像下面这样的一个函数，它会将每一个参数值转换成它的SQL字面量符号。

```lang-go
func sqlQuote(x interface{}) string {
    if x == nil {
        return "NULL"
    } else if _, ok := x.(int); ok {
        return fmt.Sprintf("%d", x)
    } else if _, ok := x.(uint); ok {
        return fmt.Sprintf("%d", x)
    } else if b, ok := x.(bool); ok {
        if b {
            return "TRUE"
        }
        return "FALSE"
    } else if s, ok := x.(string); ok {
        return sqlQuoteString(s) // (not shown)
    } else {
        panic(fmt.Sprintf("unexpected type %T: %v", x, x))
    }
}

```

switch语句可以简化if-else链，如果这个if-else链对一连串值做相等测试。一个相似的type switch（类型分支）可以简化类型断言的if-else链。

在最简单的形式中，一个类型分支像普通的switch语句一样，它的运算对象是x.(type)——它使用了关键词字面量type——并且每个case有一到多个类型。一个类型分支基于这个接口值的动态类型使一个多路分支有效。这个nil的case和if x == nil匹配，并且这个default的case和如果其它case都不匹配的情况匹配。一个对sqlQuote的类型分支可能会有这些case：

```lang-go
switch x.(type) {
case nil:       // ...
case int, uint: // ...
case bool:      // ...
case string:    // ...
default:        // ...
}

```

和（§1.8）中的普通switch语句一样，每一个case会被顺序的进行考虑，并且当一个匹配找到时，这个case中的内容会被执行。当一个或多个case类型是接口时，case的顺序就会变得很重要，因为可能会有两个case同时匹配的情况。default case相对其它case的位置是无所谓的。它不会允许落空发生。

注意到在原来的函数中，对于bool和string情况的逻辑需要通过类型断言访问提取的值。因为这个做法很典型，类型分支语句有一个扩展的形式，它可以将提取的值绑定到一个在每个case范围内都有效的新变量。

```lang-go
switch x := x.(type) { /* ... */ }

```

这里我们已经将新的变量也命名为x；和类型断言一样，重用变量名是很常见的。和一个switch语句相似地，一个类型分支隐式的创建了一个词法块，因此新变量x的定义不会和外面块中的x变量冲突。每一个case也会隐式的创建一个单独的词法块。

使用类型分支的扩展形式来重写sqlQuote函数会让这个函数更加的清晰：

```lang-go
func sqlQuote(x interface{}) string {
    switch x := x.(type) {
    case nil:
        return "NULL"
    case int, uint:
        return fmt.Sprintf("%d", x) // x has type interface{} here.
    case bool:
        if x {
            return "TRUE"
        }
        return "FALSE"
    case string:
        return sqlQuoteString(x) // (not shown)
    default:
        panic(fmt.Sprintf("unexpected type %T: %v", x, x))
    }
}

```

在这个版本的函数中，在每个单一类型的case内部，变量x和这个case的类型相同。例如，变量x在bool的case中是bool类型和string的case中是string类型。在所有其它的情况中，变量x是switch运算对象的类型（接口）；在这个例子中运算对象是一个interface{}。当多个case需要相同的操作时，比如int和uint的情况，类型分支可以很容易的合并这些情况。

尽管sqlQuote接受一个任意类型的参数，但是这个函数只会在它的参数匹配类型分支中的一个case时运行到结束；其它情况的它会panic出“unexpected type”消息。虽然x的类型是interface{}，但是我们把它认为是一个int，uint，bool，string，和nil值的discriminated union（可识别联合）

## 交流学习

如果有疑问或想和我交流，欢迎扫码下方二维码

![polarisxu](https://static.studygolang.com/static/img/polarisxu-qrcode-m.jpg?imageView2/2/w/154)

polarisxu

![gopherstudio](https://static.studygolang.com/static/img/gopherstudio2.png?imageView2/2/w/154)

gopherstudio

[Previous page: 通过类型断言查询接口](ch7-12.md)[Next page: 示例: 基于标记的XML解码](ch7-14.md)