实现接口的条件 · Go语言圣经

- [前言](../)- [Go语言起源](../ch0/ch0-01.md)
    - [Go语言项目](../ch0/ch0-02.md)
    - [本书的组织](../ch0/ch0-03.md)
    - [更多的信息](../ch0/ch0-04.md)
    - [致谢](../ch0/ch0-05.md)
- [入门](../ch1/ch1.md)- [Hello, World](../ch1/ch1-01.md)
    - [命令行参数](../ch1/ch1-02.md)
    - [查找重复的行](../ch1/ch1-03.md)
    - [GIF动画](../ch1/ch1-04.md)
    - [获取URL](../ch1/ch1-05.md)
    - [并发获取多个URL](../ch1/ch1-06.md)
    - [Web服务](../ch1/ch1-07.md)
    - [本章要点](../ch1/ch1-08.md)
- [程序结构](../ch2/ch2.md)- [命名](../ch2/ch2-01.md)
    - [声明](../ch2/ch2-02.md)
    - [变量](../ch2/ch2-03.md)
    - [赋值](../ch2/ch2-04.md)
    - [类型](../ch2/ch2-05.md)
    - [包和文件](../ch2/ch2-06.md)
    - [作用域](../ch2/ch2-07.md)
- [基础数据类型](../ch3/ch3.md)- [整型](../ch3/ch3-01.md)
    - [浮点数](../ch3/ch3-02.md)
    - [复数](../ch3/ch3-03.md)
    - [布尔型](../ch3/ch3-04.md)
    - [字符串](../ch3/ch3-05.md)
    - [常量](../ch3/ch3-06.md)
- [复合数据类型](../ch4/ch4.md)- [数组](../ch4/ch4-01.md)
    - [Slice](../ch4/ch4-02.md)
    - [Map](../ch4/ch4-03.md)
    - [结构体](../ch4/ch4-04.md)
    - [JSON](../ch4/ch4-05.md)
    - [文本和HTML模板](../ch4/ch4-06.md)
- [函数](../ch5/ch5.md)- [函数声明](../ch5/ch5-01.md)
    - [递归](../ch5/ch5-02.md)
    - [多返回值](../ch5/ch5-03.md)
    - [错误](../ch5/ch5-04.md)
    - [函数值](../ch5/ch5-05.md)
    - [匿名函数](../ch5/ch5-06.md)
    - [可变参数](../ch5/ch5-07.md)
    - [Deferred函数](../ch5/ch5-08.md)
    - [Panic异常](../ch5/ch5-09.md)
    - [Recover捕获异常](../ch5/ch5-10.md)
- [方法](../ch6/ch6.md)- [方法声明](../ch6/ch6-01.md)
    - [基于指针对象的方法](../ch6/ch6-02.md)
    - [通过嵌入结构体来扩展类型](../ch6/ch6-03.md)
    - [方法值和方法表达式](../ch6/ch6-04.md)
    - [示例: Bit数组](../ch6/ch6-05.md)
    - [封装](../ch6/ch6-06.md)
- [接口](ch7.md)- [接口是合约](ch7-01.md)
    - [接口类型](ch7-02.md)
    - [实现接口的条件](ch7-03.md)
    - [flag.Value接口](ch7-04.md)
    - [接口值](ch7-05.md)
    - [sort.Interface接口](ch7-06.md)
    - [http.Handler接口](ch7-07.md)
    - [error接口](ch7-08.md)
    - [示例: 表达式求值](ch7-09.md)
    - [类型断言](ch7-10.md)
    - [基于类型断言识别错误类型](ch7-11.md)
    - [通过类型断言查询接口](ch7-12.md)
    - [类型分支](ch7-13.md)
    - [示例: 基于标记的XML解码](ch7-14.md)
    - [补充几点](ch7-15.md)
- [Goroutines和Channels](../ch8/ch8.md)- [Goroutines](../ch8/ch8-01.md)
    - [示例: 并发的Clock服务](../ch8/ch8-02.md)
    - [示例: 并发的Echo服务](../ch8/ch8-03.md)
    - [Channels](../ch8/ch8-04.md)
    - [并发的循环](../ch8/ch8-05.md)
    - [示例: 并发的Web爬虫](../ch8/ch8-06.md)
    - [基于select的多路复用](../ch8/ch8-07.md)
    - [示例: 并发的目录遍历](../ch8/ch8-08.md)
    - [并发的退出](../ch8/ch8-09.md)
    - [示例: 聊天服务](../ch8/ch8-10.md)
- [基于共享变量的并发](../ch9/ch9.md)- [竞争条件](../ch9/ch9-01.md)
    - [sync.Mutex互斥锁](../ch9/ch9-02.md)
    - [sync.RWMutex读写锁](../ch9/ch9-03.md)
    - [内存同步](../ch9/ch9-04.md)
    - [sync.Once惰性初始化](../ch9/ch9-05.md)
    - [竞争条件检测](../ch9/ch9-06.md)
    - [示例: 并发的非阻塞缓存](../ch9/ch9-07.md)
    - [Goroutines和线程](../ch9/ch9-08.md)
- [包和工具](../ch10/ch10.md)- [包简介](../ch10/ch10-01.md)
    - [导入路径](../ch10/ch10-02.md)
    - [包声明](../ch10/ch10-03.md)
    - [导入声明](../ch10/ch10-04.md)
    - [包的匿名导入](../ch10/ch10-05.md)
    - [包和命名](../ch10/ch10-06.md)
    - [工具](../ch10/ch10-07.md)
- [测试](../ch11/ch11.md)- [go test](../ch11/ch11-01.md)
    - [测试函数](../ch11/ch11-02.md)
    - [测试覆盖率](../ch11/ch11-03.md)
    - [基准测试](../ch11/ch11-04.md)
    - [剖析](../ch11/ch11-05.md)
    - [示例函数](../ch11/ch11-06.md)
- [反射](../ch12/ch12.md)- [为何需要反射?](../ch12/ch12-01.md)
    - [reflect.Type和reflect.Value](../ch12/ch12-02.md)
    - [Display递归打印](../ch12/ch12-03.md)
    - [示例: 编码S表达式](../ch12/ch12-04.md)
    - [通过reflect.Value修改值](../ch12/ch12-05.md)
    - [示例: 解码S表达式](../ch12/ch12-06.md)
    - [获取结构体字段标签](../ch12/ch12-07.md)
    - [显示一个类型的方法集](../ch12/ch12-08.md)
    - [几点忠告](../ch12/ch12-09.md)
- [底层编程](../ch13/ch13.md)- [unsafe.Sizeof, Alignof 和 Offsetof](../ch13/ch13-01.md)
    - [unsafe.Pointer](../ch13/ch13-02.md)
    - [示例: 深度相等判断](../ch13/ch13-03.md)
    - [通过cgo调用C代码](../ch13/ch13-04.md)
    - [几点忠告](../ch13/ch13-05.md)
- [附录](../appendix/appendix.html)- [附录A：原文勘误](../appendix/appendix-a-errata.html)
    - [附录B：作者译者](../appendix/appendix-b-author.html)
    - [附录C：译文授权](../appendix/appendix-c-cpoyright.html)
    - [附录D：其它语言](../appendix/appendix-d-translations.html)
- [本书使用 GitBook 发布](https://www.gitbook.com)

# [实现接口的条件](..)

## 7.3. 实现接口的条件

一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。例如，`*os.File`类型实现了io.Reader，Writer，Closer，和ReadWriter接口。`*bytes.Buffer`实现了Reader，Writer，和ReadWriter这些接口，但是它没有实现Closer接口因为它不具有Close方法。Go的程序员经常会简要的把一个具体的类型描述成一个特定的接口类型。举个例子，`*bytes.Buffer`是io.Writer；`*os.Files`是io.ReadWriter。

接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。所以：

```lang-go
var w io.Writer
w = os.Stdout           // OK: *os.File has Write method
w = new(bytes.Buffer)   // OK: *bytes.Buffer has Write method
w = time.Second         // compile error: time.Duration lacks Write method

var rwc io.ReadWriteCloser
rwc = os.Stdout         // OK: *os.File has Read, Write, Close methods
rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method

```

这个规则甚至适用于等式右边本身也是一个接口类型

```lang-go
w = rwc                 // OK: io.ReadWriteCloser has Write method
rwc = w                 // compile error: io.Writer lacks Close method

```

因为ReadWriter和ReadWriteCloser包含有Writer的方法，所以任何实现了ReadWriter和ReadWriteCloser的类型必定也实现了Writer接口

在进一步学习前，必须先解释一个类型持有一个方法的表示当中的细节。回想在6.2章中，对于每一个命名过的具体类型T；它的一些方法的接收者是类型T本身然而另一些则是一个`*T`的指针。还记得在T类型的参数上调用一个`*T`的方法是合法的，只要这个参数是一个变量；编译器隐式的获取了它的地址。但这仅仅是一个语法糖：T类型的值不拥有所有`*T`指针的方法，这样它就可能只实现了更少的接口。

举个例子可能会更清晰一点。在第6.5章中，IntSet类型的String方法的接收者是一个指针类型，所以我们不能在一个不能寻址的IntSet值上调用这个方法：

```lang-go
type IntSet struct { /* ... */ }
func (*IntSet) String() string
var _ = IntSet{}.String() // compile error: String requires *IntSet receiver

```

但是我们可以在一个IntSet变量上调用这个方法：

```lang-go
var s IntSet
var _ = s.String() // OK: s is a variable and &s has a String method

```

然而，由于只有`*IntSet`类型有String方法，所以也只有`*IntSet`类型实现了fmt.Stringer接口：

```lang-go
var _ fmt.Stringer = &s // OK
var _ fmt.Stringer = s  // compile error: IntSet lacks String method

```

12.8章包含了一个打印出任意值的所有方法的程序，然后可以使用godoc -analysis=type tool(§10.7.4)展示每个类型的方法和具体类型和接口之间的关系

就像信封封装和隐藏起信件来一样，接口类型封装和隐藏具体类型和它的值。即使具体类型有其它的方法，也只有接口类型暴露出来的方法会被调用到：

```lang-go
os.Stdout.Write([]byte("hello")) // OK: *os.File has Write method
os.Stdout.Close()                // OK: *os.File has Close method

var w io.Writer
w = os.Stdout
w.Write([]byte("hello")) // OK: io.Writer has Write method
w.Close()                // compile error: io.Writer lacks Close method

```

一个有更多方法的接口类型，比如io.ReadWriter，和少一些方法的接口类型例如io.Reader，进行对比；更多方法的接口类型会告诉我们更多关于它的值持有的信息，并且对实现它的类型要求更加严格。那么关于interface{}类型，它没有任何方法，请讲出哪些具体的类型实现了它？

这看上去好像没有用，但实际上interface{}被称为空接口类型是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。

```lang-go
var any interface{}
any = true
any = 12.34
any = "hello"
any = map[string]int{"one": 1}
any = new(bytes.Buffer)

```

尽管不是很明显，从本书最早的例子中我们就已经在使用空接口类型。它允许像fmt.Println或者5.7章中的errorf函数接受任何类型的参数。

对于创建的一个interface{}值持有一个boolean，float，string，map，pointer，或者任意其它的类型；我们当然不能直接对它持有的值做操作，因为interface{}没有任何方法。我们会在7.10章中学到一种用类型断言来获取interface{}中值的方法。

因为接口与实现只依赖于判断两个类型的方法，所以没有必要定义一个具体类型和它实现的接口之间的关系。也就是说，有意地在文档里说明或者程序上断言这种关系偶尔是有用的，但程序上不强制这么做。下面的定义在编译期断言一个`*bytes.Buffer`的值实现了io.Writer接口类型:

```lang-go
// *bytes.Buffer must satisfy io.Writer
var w io.Writer = new(bytes.Buffer)

```

因为任意`*bytes.Buffer`的值，甚至包括nil通过`(*bytes.Buffer)(nil)`进行显示的转换都实现了这个接口，所以我们不必分配一个新的变量。并且因为我们绝不会引用变量w，我们可以使用空标识符来进行代替。总的看，这些变化可以让我们得到一个更朴素的版本：

```lang-go
// *bytes.Buffer must satisfy io.Writer
var _ io.Writer = (*bytes.Buffer)(nil)

```

非空的接口类型比如io.Writer经常被指针类型实现，尤其当一个或多个接口方法像Write方法那样隐式的给接收者带来变化的时候。一个结构体的指针是非常常见的承载方法的类型。

但是并不意味着只有指针类型满足接口类型，甚至连一些有设置方法的接口类型也可能会被Go语言中其它的引用类型实现。我们已经看过slice类型的方法（geometry.Path，§6.1）和map类型的方法（url.Values，§6.2.1），后面还会看到函数类型的方法的例子（http.HandlerFunc，§7.7）。甚至基本的类型也可能会实现一些接口；就如我们在7.4章中看到的time.Duration类型实现了fmt.Stringer接口。

一个具体的类型可能实现了很多不相关的接口。考虑在一个组织出售数字文化产品比如音乐，电影和书籍的程序中可能定义了下列的具体类型：

```
Album
Book
Movie
Magazine
Podcast
TVEpisode
Track

```

我们可以把每个抽象的特点用接口来表示。一些特性对于所有的这些文化产品都是共通的，例如标题，创作日期和作者列表。

```lang-go
type Artifact interface {
    Title() string
    Creators() []string
    Created() time.Time
}

```

其它的一些特性只对特定类型的文化产品才有。和文字排版特性相关的只有books和magazines，还有只有movies和TV剧集和屏幕分辨率相关。

```lang-go
type Text interface {
    Pages() int
    Words() int
    PageSize() int
}
type Audio interface {
    Stream() (io.ReadCloser, error)
    RunningTime() time.Duration
    Format() string // e.g., "MP3", "WAV"
}
type Video interface {
    Stream() (io.ReadCloser, error)
    RunningTime() time.Duration
    Format() string // e.g., "MP4", "WMV"
    Resolution() (x, y int)
}

```

这些接口不止是一种有用的方式来分组相关的具体类型和表示他们之间的共同特点。我们后面可能会发现其它的分组。举例，如果我们发现我们需要以同样的方式处理Audio和Video，我们可以定义一个Streamer接口来代表它们之间相同的部分而不必对已经存在的类型做改变。

```lang-go
type Streamer interface {
    Stream() (io.ReadCloser, error)
    RunningTime() time.Duration
    Format() string
}

```

每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。不像基于类的语言，他们一个类实现的接口集合需要进行显式的定义，在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。当具体的类型来自不同的作者时这种方式会特别有用。当然也确实没有必要在具体的类型中指出这些共性。

## 交流学习

如果有疑问或想和我交流，欢迎扫码下方二维码

![polarisxu](https://static.studygolang.com/static/img/polarisxu-qrcode-m.jpg?imageView2/2/w/154)

polarisxu

![gopherstudio](https://static.studygolang.com/static/img/gopherstudio2.png?imageView2/2/w/154)

gopherstudio

[Previous page: 接口类型](ch7-02.md)[Next page: flag.Value接口](ch7-04.md)